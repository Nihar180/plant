


import random
random.seed(0)

import numpy as np
np.random.seed(0)

import tensorflow as tf
tf.random.set_seed(0)


import os
import json
from zipfile import ZipFile
from PIL import Image

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras import layers,models


!pip install kaggle


from google.colab import files
uploaded = files.upload()



import json
kaggle_credentials=json.load(open("kaggle.json"))


import os
os.environ["KAGGLE_USERNAME"]=kaggle_credentials["username"]
os.environ["KAGGLE_KEY"]=kaggle_credentials["key"]


!kaggle datasets download -d emmarex/plantdisease  # smaller version (~4‚Äì5 leaf diseases)
!unzip plantdisease.zip -d dataset

!ls dataset


!ls


import zipfile
zip_path = "/content/plantdisease.zip"  # changed line
extract_path = "/content/dataset"
with zipfile.ZipFile(zip_path, 'r') as z:
    z.extractall(extract_path)
print("Extraction complete!")

# Check extracted contents
!ls /content/dataset




import os
print(os.listdir("/content/dataset"))

import shutil

# Path to main dataset
base_path = "/content/dataset"

# Paths to both "plantvillage" folders (adjust if needed)
folder1 = os.path.join(base_path, "plantvillage")
folder2 = os.path.join(base_path, "plantvillage (1)", "plantvillage")

# Create a clean merged folder



import os

path = "/content/dataset"
for root, dirs, files in os.walk(path):
    print(root)
    break  # only print top level

/content/dataset


import os

# Path correction
base_path = "/content/dataset"

# In your dataset, some folders like PlantVillage contain the actual data inside them.
# So we detect where the class folders actually are.
subfolders = os.listdir(base_path)
print("Top-level folders:", subfolders)




from tensorflow.keras.preprocessing.image import ImageDataGenerator

img_size = (224, 224)
batch_size = 32

datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2
)

train_generator = datagen.flow_from_directory(
    dataset_path,
    target_size=img_size,
    batch_size=batch_size,
    subset='training'
)

validation_generator = datagen.flow_from_directory(
    dataset_path,
    target_size=img_size,
    batch_size=batch_size,
    subset='validation'
)


from tensorflow.keras.preprocessing.image import ImageDataGenerator

img_size = (224, 224)
batch_size = 32

datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2
)

train_generator = datagen.flow_from_directory(
    dataset_path,
    target_size=img_size,
    batch_size=batch_size,
    subset='training'
)

validation_generator = datagen.flow_from_directory(
    dataset_path,
    target_size=img_size,
    batch_size=batch_size,
    subset='validation'
)



from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

model = Sequential([
    Conv2D(32, (3,3), activation='relu', input_shape=(224,224,3)),
    MaxPooling2D(2,2),

    Conv2D(64, (3,3), activation='relu'),
    MaxPooling2D(2,2),

    Conv2D(128, (3,3), activation='relu'),
    MaxPooling2D(2,2),

    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.3),
    Dense(train_generator.num_classes, activation='softmax')
])

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
model.summary()



history = model.fit(
    train_generator,
    epochs=10,
    validation_data=validation_generator
)




import matplotlib.pyplot as plt

plt.figure(figsize=(12,5))
plt.subplot(1,2,1)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.legend()
plt.title('Accuracy')

plt.subplot(1,2,2)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.legend()
plt.title('Loss')
plt.show()




print(sorted(train_generator.class_indices.keys()))



disease_info = {
    "Pepper__bell___Bacterial_spot": {
        "cause": "Bacterium (Xanthomonas campestris pv. vesicatoria)",
        "prevention": "Use certified disease-free seeds, avoid overhead irrigation, remove infected plants, and apply copper-based bactericides."
    },
    "Pepper__bell___healthy": {
        "cause": "No disease",
        "prevention": "Maintain proper watering, ensure good drainage, and monitor regularly for pest activity."
    },
    "Potato___Early_blight": {
        "cause": "Fungus (Alternaria solani)",
        "prevention": "Use resistant varieties, remove infected debris, and apply fungicides early in the growing season."
    },
    "Potato___Late_blight": {
        "cause": "Oomycete (Phytophthora infestans)",
        "prevention": "Use certified seed potatoes, avoid overhead watering, and apply fungicides preventively."
    },
    "Potato___healthy": {
        "cause": "No disease",
        "prevention": "Use healthy tubers, rotate crops yearly, and maintain proper field hygiene."
    },
    "Tomato_Bacterial_spot": {
        "cause": "Bacterium (Xanthomonas vesicatoria)",
        "prevention": "Use disease-free seed, avoid handling plants when wet, and apply copper-based sprays."
    },
    "Tomato_Early_blight": {
        "cause": "Fungus (Alternaria solani)",
        "prevention": "Rotate crops, prune lower leaves, avoid wet foliage, and apply fungicides."
    },
    "Tomato_Late_blight": {
        "cause": "Oomycete (Phytophthora infestans)",
        "prevention": "Remove infected plants, improve airflow, and use resistant varieties or fungicides."
    },
    "Tomato_Leaf_Mold": {
        "cause": "Fungus (Passalora fulva)",
        "prevention": "Ensure good air circulation, reduce humidity, and apply appropriate fungicides."
    },
    "Tomato_Septoria_leaf_spot": {
        "cause": "Fungus (Septoria lycopersici)",
        "prevention": "Remove infected leaves, use crop rotation, and apply preventive fungicides."
    },
    "Tomato_Spider_mites_Two_spotted_spider_mite": {
        "cause": "Insect (Tetranychus urticae ‚Äî Spider mites)",
        "prevention": "Maintain humidity, wash leaves with water spray, and apply neem oil or miticides if severe."
    },
    "Tomato__Target_Spot": {
        "cause": "Fungus (Corynespora cassiicola)",
        "prevention": "Avoid water splashing, remove infected debris, and use protective fungicides."
    },
    "Tomato__Tomato_YellowLeaf__Curl_Virus": {
        "cause": "Virus (Tomato Yellow Leaf Curl Virus ‚Äî transmitted by whiteflies)",
        "prevention": "Control whiteflies with nets or insecticides, use resistant varieties, and remove infected plants."
    },
    "Tomato__Tomato_mosaic_virus": {
        "cause": "Virus (Tomato Mosaic Virus ‚Äî ToMV)",
        "prevention": "Disinfect tools, wash hands before handling plants, and remove infected plants immediately."
    },
    "Tomato_healthy": {
        "cause": "No disease",
        "prevention": "Maintain balanced watering and fertilization, and regularly inspect plants for early signs of stress."
    }
}




from google.colab import files
from tensorflow.keras.preprocessing import image
import numpy as np
from PIL import Image

uploaded = files.upload()

for fn in uploaded.keys():
    try:
        # Load and preprocess image
        path = fn
        img = Image.open(path).convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img) / 255.0
        img_array = np.expand_dims(img_array, axis=0)

        # Predict
        pred = model.predict(img_array)
        class_index = np.argmax(pred)
        class_label = list(train_generator.class_indices.keys())[class_index]
        confidence = round(100 * np.max(pred), 2)

        print(f"\nüåø Prediction: {class_label}")
        print(f"‚úÖ Confidence: {confidence}%")

        if class_label in disease_info:
            print(f"ü©∫ Cause: {disease_info[class_label]['cause']}")
            print(f"üåø Prevention: {disease_info[class_label]['prevention']}")
        else:
            print("‚ö†Ô∏è No disease information available for this class.")
    except Exception as e:
        print(f"‚ùå Error processing {fn}: {e}")






# Save model (HDF5)
model.save("/content/plant_model.h5")
print("Saved at /content/plant_model.h5")

# Then download to your local machine
from google.colab import files
files.download("/content/plant_model.h5")



